# 1/ Реализуйте генераторную функцию, которая будет возвращать по одному
# члену числовой последовательности, закон которой задается с помощью
# пользовательской функции. Кроме этого параметром генераторной функции
# должны быть значение первого члена прогрессии и количество выдаваемых
# членов последовательности (n). Генератор должен остановить свою работу
# или по достижению n — го члена, или при передаче команды на завершение.

def generator_func(start, stop, rulefunc):
    if not isinstance(start, int) or not isinstance(stop, int):
        raise TypeError
    for i in rulefunc(start, stop):
        yield i


def rule_mul(a, end):
    res = []
    while len(res) < end:
        res.append(a * 2)
        a += 1
    return res


def rule_sqrt(a, end):
    res = []
    while len(res) < end:
        res.append(a ** 2)
        a += 1
    return res


res = generator_func(1, 20, rule_sqrt)
for i in res:
    print(i, end=' ')


# 2/ Используя функцию замыкания реализуйте такой прием программирования
# как Мемоизация - https://en.wikipedia.org/wiki/Memoization
# Используйте полученный механизм для ускорения функции рекурсивного
# вычисления n — го члена ряда Фибоначчи. Сравните скорость выполнения с
# просто рекурсивным подходом.

#     ---НИЧЕГО НЕ ПОЛУЧАЕТСЯ(---





# 3/ Напишите функцию, которая применит к списку чисел произвольную
# пользовательскую функцию и вернет суммы элементов полученного списка


listnum = [20, 15, 44, 90, 33, 70]
res = sum(list(map(lambda x: x * 3, listnum)))
print(res)